# 第一章

# 第二章

## 2.1.1

## 2.2

## 2.3 线性结构和非线形结构

数据结构包括：线性结构和非线性结构

### 2.3.1 线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系

2. 线性结构有两种不同的存储结构，即**顺序存储结构**和**链式存储结构**。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的（存储地址）
3. 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息

4. 常见的线性结构有：数组、队列、链表和栈

### 2.3.2 非线性结构

1. 非线性结构包括：二维数组、多维数组、广义表、树结构、图结构

# 第三章 稀疏数组和队列

## 3.1 稀疏 sparsearray 数组

### 3.1.1 实际的需求

**编写的五子棋程序中，有存盘退出和续上盘的功能**

<img src="数据结构和算法.assets/image-20210922215616315.png" alt="image-20210922215616315" style="zoom:50%;" />

**分析问题**

因为左侧二维数组中存放了很多的默认值0，因此**记录了很多没有意义的数据**-->稀疏数组

### 3.1.2 基本介绍

当一个数组中大部分元素为0，或者为同一个值时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法

1. 记录数组一共有几行几列，有多少个值
2. 把具有不同值的元素的行列及值信息记录在一个小规模的数组中，从而缩小程序的规模

**稀疏数组举例说明**

<img src="数据结构和算法.assets/image-20210922220343732.png" alt="image-20210922220343732" style="zoom:50%;" />

### 3.1.3 应用实例

**二维数组转稀疏数组**

1. 遍历原始的二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int\[sum+1][3]
3. 将二维数组的有效数据存入到稀疏数组

**稀疏数组转二维数组**

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
2. 在读取稀疏数据后几行的数据，并赋值给二维数组即可

## 3.2 队列

### 3.2.1 队列的使用场景

银行排队的案例

<img src="数据结构和算法.assets/image-20210923233131975.png" alt="image-20210923233131975" style="zoom:50%;" />

### 3.2.2 队列介绍

1. 队列是一个有序列表，可以使用**数组**或者是**链表**来实现

2. 队列遵循先进先出的原则。即：先存入队列的数据，要先取出；后存入队列的数据后取出。

3. 使用数组模拟队列的示意图

   <img src="数据结构和算法.assets/image-20210923233150887.png" alt="image-20210923233150887" style="zoom:50%;" />

### 3.2.3 数组实现队列思路

- 队列本身是有序列表。若使用数组来实现队列存储数据，则队列数组声明如上图所示，其中MaxSize是该队列的最大容量
- 因为队列的输入、输出是分别从起始和末尾来处理，因此需要两个变量front和rear分别记录队列的起始位置和末尾位置。front会随着数据的输出而改变，rear会随着数据的输入而改变。front和rear初始设置为-1。
- 当有数据入队列时，需要考虑如下
  - 当前队列是否已满。rear==MaxSize-1，如果满了则无法存数据
  - rear末尾下标指示后移rear++，将数据存入rear所指的数组中
- 当有数据出队列时，需要考虑如下
  - 当前队列是否空。front==rear，如果队列为空则无数据可出
  - front起始位置后移front++，返回当前front位置的数据

 **问题分析**

1. 使用数组模拟队列，当队列状态满了之后，数组就不能再继续使用了。
2. 可以改成一个**环状的队列**，取模%

### 3.2.4 数组模拟环形队列

对数组模拟队列的优化，充分利用数组，因此将数组看作是一个环形的（通过**取模的方式**来实现）。

**分析说明**

1. front指向当前队列头元素，初始位置为0
2. rear指向队列尾元素的下一个位置，初始位置为0
3. 当(rear+1)%maxSize=front时 表示队列满了
4. 当rear=front时表示队列为空
5. 当队列增加元素时rear=(rear+1)%maxSize
6. 当元素从队列里取出时front=(front+1)%maxSize

<img src="数据结构和算法.assets/image-20210923233150887.png" alt="image-20210923233150887" style="zoom:50%;" />

# 第四章 链表

## 4.1 链表介绍

链表是有顺序的列表，它在内存中存储如下：

<img src="数据结构和算法.assets/image-20210926235349178.png" alt="image-20210926235349178" style="zoom:50%;" />

1. 链表是以节点的方式来存储，是链式存储。
2. 每个节点包含一个data域，一个next域
3. 链表的各个节点不一定是连续存储的
4. 链表分带头节点和不带头节点的的链表，根据实际的需求来确定

## 4.2 单链表的应用实例

> 使用带头节点的单向链表实现英雄排行榜管理。完成对英雄人物的增删改查操作



**直接添加到链表尾部逻辑分析**

- 链表头节点用来做为牵引头，不移动

- 当节点的next属性为空时表示链表最后

- 添加节点时，从头节点获取第一个有效数据，开始遍历链表找到最后一个节点，将待添加的节点添加到最后



**按顺序添加节点分析**

- 从头节点开始获取有效节点（next）开始进行遍历链表

- 判断是否到达链表的最后，如果是则可以直接添加，否则进行下一步
- 判断当前节点的下一个节点的值是否大于要添加的节点的值，是跳出循环进行下一步，否继续遍历
- 判断当前节点的下一个节点的值是否等于要添加的节点的值，是跳出循环进行下一步，同时标识有相同节点，否继续遍历
- 判断是否是相同的节点，如果是相同的节点，输出提示不进行添加，如果不是相同节点进行下一步
- 将待添加节点的next指向当前节点的next，再将当前节点的next指向待添加节点

<img src="数据结构和算法.assets/image-20210926233401806.png" alt="image-20210926233401806" style="zoom:50%;" />

**删除节点逻辑分析**

- 如果到最后节点了，说明不存在要删除的节点

- 找到需要删除节点的前一个节点temp
- 将temp.next=temp.next.next

**更新节点逻辑分析**

- 如果是空节点，则更新操作不能完成，否则进行下一步
- 判断是否是要更新的节点，是则更新，否继续循环查找

## 4.3 单链表面试题

**求单链表有效节点的个数**

- 遍历链表，进行加一，直到最后一个节点

**查找单链表中倒数第k个节点**

- 判断k是否有效，即k不能小于等于0，也不能大于有效节点个数
- 倒数第k个就是正数第（length-k）个
- for循环遍历到第（length-k）个节点，就是要查找的倒数第k个节点

**单链表反转**

- 创建一个新的头节点revertHead，
- 对要反转的链表进行遍历，遍历时将当前遍历的节点取出，放到新的链表的最前面
- 将原来链表的头节点的next指向revertHead的next

**合并两个有序链表**

- 其实就是对链表的节点进行有序添加



## 4.4 双向链表应用实例

### 4.4.1 双向链表的操作分析和实现

- next指向当前节点的下一个节点
- pre指向当前节点的前一个节点

**单向链表的缺点分析**

- 单项链表的查找方向只能是一个方向，而双向链表可以向前或者向后查找
- 单项链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除

**双向链表的遍历**

遍历的方式和单链表一样，区别是双向链表可以向前查找，也可以向后查找

**添加节点到双向链表的最后**

- 先找到尾节点temp
- 让temp.next=newNode，同时让newNode.pre=temp

**双向链表的修改**

修改和单向链表一样

**双向链表的删除**

- 找到要删除的节点temp
- 执行temp.pre.next=temp.next，同时让temp.next.pre=temp.pre

## 4.5 单向环形链表

如下图所示是一个节点和多个节点时单向环形链表的状态。

当只有一个节点时，该节点的next域指向自己。

![image-20211007094049356](数据结构和算法.assets/image-20211007094049356.png)

## 4.6 单向环形链表应用场景

Josephu（约瑟夫）问题

Josephu问题为:设编号为 1，2，... n 的 n 个人围坐一圈，约定编号为 k(1<=k<=n)的人从 1 开始报数，数 到 m 的那个人出圈，它的下一位又从 1 开始报数，数到 m 的那个人又出圈，依次类推，直到所有人出列为止，由 此产生一个出圈编号的序列。

提示:用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。

## 4.7 Josephu问题

需要一个first变量，用来代表环的起始。

### 4.7.1 初始化环

- 环的大小应该不小于1，否则无意义
- 一个指向当前末尾的节点变量currentNode，保证currentNode.next=first
- 添加的节点temp

**添加节点的操作步骤**

1. 创建一个节点temp

2. 判断节点编号是不是1即第一个节点，如果是就让first变量指向它，同时让currentNode也指向它，然后设置currentNode.next=first；

3. 如果不是一号节点，让currentNode.next=temp；然后让currentNode指向temp，然后设置currentNode.next=first；

![image-20211007103959269](数据结构和算法.assets/image-20211007103959269.png)

### 4.7.2 出圈

**出圈的操作步骤**

1. 创建一个辅助节点helperNode，该节点初始指向队列的末尾节点。

2. 根据startNo，同步的移动helperNode和first，此时helperNode的next指向first

3. 然后再找到要出圈的节点delNode，根据计数的次数countNo。循环得到delNode的位置
4. 让firstNode指向delNode.next，让helperNode.next指向first节点helperNode.next=first

![image-20211007115702377](数据结构和算法.assets/image-20211007115702377.png)

# 第五章 栈

## 5.1 栈的一个实际需求

计算表达式的值

![image-20211007223208331](数据结构和算法.assets/image-20211007223208331.png)

计算机底层是如何运算得到结果的? 我们看这个算式 7 * 2 * 2 - 5, 但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)

## 5.2 栈的介绍

1. 栈也称为stack
2. 栈是一个先入后出的有序列表
3. 栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端称为**栈顶**，另一端为固定的一端称为**栈底**。
4. 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶；而删除元素则刚好相反，最后放入的元素最先被删除，最先放入的元素最后被删除
5. 如下图所示

![image-20211007223803375](数据结构和算法.assets/image-20211007223803375.png)

## 5.3 栈的应用场景

1. 子程序的调用：在跳往子程序前，会先将当前程序的下个指令的地址存到栈中，直到子程序执行完后在将地址取出，以回到原来的程序中
2. 处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入了栈中
3. 表达式的转换（中缀表达式转后缀表达式）与求值
4. 二叉树的遍历
5. 图的深度优先搜索法

## 5.4 栈的快速入门

1. 用数组模拟栈的使用，由于栈是一种有序列表，所以可以使用数组的结构来存储栈的数据结构
2. 实现思路如下：
   1. 定义top表示栈顶，初始值为-1
   2. 入栈操作，top++;stack[top]=value
   3. 出栈操作，int value=stack[top]; top--;

![image-20211008222846222](数据结构和算法.assets/image-20211008222846222.png)

​	

## 5.5 栈实现综合计算器（中缀表达式）

使用栈来实现综合计算器（此时只有正整数的加减乘除运算）。

输入一个表达式[7\*2\*2-5+1-5+3]计算结果。

思路分析：

![image-20211008222846222](数据结构和算法.assets/image-20211010222846222.png)

## 5.6 逆波兰计算器

### 5.6.1 前缀表达式

前缀表达式又称波兰表达式。前缀表达式的运算符位于操作数之前。

举例： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

**前缀表达式的计算过程**

从右至左扫描表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符对它们做响应的计算，并将结果入栈；重复这个过程直到表达式最左端，最后运算得出的值就是表达式的计算结果。

举例：(3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:

1. 从右至左扫描，将6、5、4、3压入栈中
2. 遇到+运算符，因此弹出3和4，计算出3+4的值，得到7，再将7入栈
3. 接下来是x运算符，因此弹出7和5，计算出7x5=35，将35入栈
4. 最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果

### 5.6.2 中缀表达式

中缀表达式就是常见的运算表达式，如(3+4)×5-6。

中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)

### 5.6.3 后缀表达式

后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

举例： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

| 正常表达式 | 逆波兰表达式  |
| ---------- | ------------- |
| a+b        | a b +         |
| a+(b-c)    | a b c - +     |
| a+(b-c)*d  | a b c – d * + |
| a+d*(b-c)  | a d b c - * + |
| a=1+3      | a 1 3 + =     |

**后缀表达式计算过程**

从左至右扫描表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈；重复这个过程直到表达式最右端，最后运算得出的值就是表达式的计算结果。

举例：(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

1. 从左至右扫描，将3和4压入栈中
2. 遇到运算符+，因此弹出3和4，计算出3+4的值，得到7，再将7入栈
3. 将5入栈
4. 接下来是 x 运算符，因此弹出5和7，计算7x5的值，得到35，将35入栈
5. 将6入栈
6. 接下来是 - 运算符，因此弹出35和6的值，计算35-6的值，得到29，由此得到最终结果。

### 5.6.4 逆波兰计算器

逆波兰表达式就是计算后缀表达式的值，这里使用jdk提供的Stack栈数据结构

## 5.7 中缀表达式转化为后缀表达式

在逆波兰表达式实现计算器中可以发现后缀表达式实现起来比较方便，但是得到后缀表达式的结果手动实现比较难，尤其表达式很长的情况下。下面看下将中缀表达式转为后缀表达式的步骤。

### 5.7.1 实现步骤

注意：*下面步骤中说的运算符是指加减乘除等运算符，左右括号()使用操作符表示，同时操作符没有优先级，只有运算符有优先级*

1. 初始化两个栈，运算符栈s1和中间结果存储的栈s2
2. 从左至右扫描中缀表达式
3. 遇到操作数时，将其压入到栈s2中
4. 遇到运算符时，将其与s1栈顶符号的优先级比较
   1. 如果s1栈顶为空，或者栈顶运算符为左括号"("，则直接将此运算符入栈到s1
   2. 否则，若优先级比栈顶运算符高，也将此运算符入栈s1
   3. 否则，将s1栈顶的符号弹出并压入到s2中，再次转到4.1
5. 遇到括号时
   1. 如果是左括号，则直接压入到s1栈中
   2. 如果是右括号，则依次弹出s1栈顶的符号，并压入到s2栈中，直到遇到左括号为止，此时将这一对括号丢弃
6. 重复步骤2-5，直到表达式扫描结束
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

### 5.7.2 举例说明

将中缀表达式“1+((2+3)*4)-5”转换为后缀表达式的过程如下：

| 扫描到的元素   | s2（栈底->栈顶）  | s1（栈底->栈顶） | 说明                                                         |
| -------------- | ----------------- | ---------------- | ------------------------------------------------------------ |
| 1              | 1                 |                  | 数字，直接入栈                                               |
| +              | 1                 | +                | 运算符，s1栈顶为空                                           |
| (              | 1                 | + (              | 是左括号，直接入栈                                           |
| (              | 1                 | + ( (            | 是左括号，直接入栈                                           |
| 2              | 1 2               | + ( (            | 数字，直接入栈                                               |
| +              | 1 2               | + ( ( +          | 运算符，此时s1栈顶是左括号，直接入栈                         |
| 3              | 1 2 3             | + ( ( +          | 数字，直接入栈                                               |
| )              | 1 2 3 +           | + (              | 右括号，循环弹出s1： 弹出+号压入到s2，直到遇到(，丢弃这一对括号 |
| *              | 1 2 3 +           | + ( *            | 运算符，此时s1栈顶是左括号，直接入栈                         |
| 4              | 1 2 3 + 4         | + ( *            | 数字，直接入栈                                               |
| )              | 1 2 3 + 4 *       | +                | 右括号，循环弹出s1： 弹出*号压入到s2，直到遇到(，丢弃这一对括号 |
| -              | 1 2 3 + 4 * +     | -                | 减号，此时s1栈顶是+ ，减号的优先级不比加号高，将s1栈顶的符号弹出并压入到s2中，继续和s1栈顶比较，这个时候s1空了，那么减号直接入栈 |
| 5              | 1 2 3 + 4 * + 5   | -                | 数字，直接入栈                                               |
| 表达式扫描结束 | 1 2 3 + 4 * + 5 - |                  | 将s1中的弹出到s2                                             |

最后的结果：1 2 3 + 4 * + 5 -

### 5.7.3 代码实现

注意：由于s2在实际操作中就是不断的添加元素，为了方便得到最后结果，在代码实现时可以使用List来代替

# 第六章 递归

## 6.1 递归应用场景

递归：recursion

## 6.2 递归的概念

简单说：递归就是方法本身调用自己。递归有助于编程者解决负责复杂的问题，同时可以让代码变得简洁。

## 6.3 递归的调用机制

方法区栈

## 6.4 递归解决的问题

1. 一些数学问题：8皇后、汉诺塔、阶乘、迷宫问题、球和篮子问题（Google编程大赛）
2. 一些算法中也会用到递归：快排、二分查找、归并排序、分治算法
3. 将用栈解决的问题使用递归解决代码比较简洁

## 6.5 递归需要遵守的规则

1. 在执行递归方法时，会将新的方法压入到方法区栈中
2. 方法中的局部变量是独立的，不会相互影响
3. 如果方法中使用的是引用类型变量，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则进入无限循环就会出现StackOverflowError。

## 6.6 递归-迷宫问题


