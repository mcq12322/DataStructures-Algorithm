# 第一章

# 第二章

## 2.1.1

## 2.2

## 2.3 线性结构和非线形结构

数据结构包括：线性结构和非线性结构

### 2.3.1 线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系

2. 线性结构有两种不同的存储结构，即**顺序存储结构**和**链式存储结构**。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的（存储地址）
3. 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息

4. 常见的线性结构有：数组、队列、链表和栈

### 2.3.2 非线性结构

1. 非线性结构包括：二维数组、多维数组、广义表、树结构、图结构

# 第三章 稀疏数组和队列

## 3.1 稀疏 sparsearray 数组

### 3.1.1 实际的需求

**编写的五子棋程序中，有存盘退出和续上盘的功能**

<img src="数据结构和算法.assets/image-20210922215616315.png" alt="image-20210922215616315" style="zoom:50%;" />

**分析问题**

因为左侧二维数组中存放了很多的默认值0，因此**记录了很多没有意义的数据**-->稀疏数组

### 3.1.2 基本介绍

当一个数组中大部分元素为0，或者为同一个值时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法

1. 记录数组一共有几行几列，有多少个值
2. 把具有不同值的元素的行列及值信息记录在一个小规模的数组中，从而缩小程序的规模

**稀疏数组举例说明**

<img src="数据结构和算法.assets/image-20210922220343732.png" alt="image-20210922220343732" style="zoom:50%;" />

### 3.1.3 应用实例

**二维数组转稀疏数组**

1. 遍历原始的二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int\[sum+1][3]
3. 将二维数组的有效数据存入到稀疏数组

**稀疏数组转二维数组**

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
2. 在读取稀疏数据后几行的数据，并赋值给二维数组即可

## 3.2 队列

### 3.2.1 队列的使用场景

银行排队的案例

<img src="数据结构和算法.assets/image-20210923233131975.png" alt="image-20210923233131975" style="zoom:50%;" />

### 3.2.2 队列介绍

1. 队列是一个有序列表，可以使用**数组**或者是**链表**来实现

2. 队列遵循先进先出的原则。即：先存入队列的数据，要先取出；后存入队列的数据后取出。

3. 使用数组模拟队列的示意图

   <img src="数据结构和算法.assets/image-20210923233150887.png" alt="image-20210923233150887" style="zoom:50%;" />

### 3.2.3 数组实现队列思路

- 队列本身是有序列表。若使用数组来实现队列存储数据，则队列数组声明如上图所示，其中MaxSize是该队列的最大容量
- 因为队列的输入、输出是分别从起始和末尾来处理，因此需要两个变量front和rear分别记录队列的起始位置和末尾位置。front会随着数据的输出而改变，rear会随着数据的输入而改变。front和rear初始设置为-1。
- 当有数据入队列时，需要考虑如下
  - 当前队列是否已满。rear==MaxSize-1，如果满了则无法存数据
  - rear末尾下标指示后移rear++，将数据存入rear所指的数组中
- 当有数据出队列时，需要考虑如下
  - 当前队列是否空。front==rear，如果队列为空则无数据可出
  - front起始位置后移front++，返回当前front位置的数据

 **问题分析**

1. 使用数组模拟队列，当队列状态满了之后，数组就不能再继续使用了。
2. 可以改成一个**环状的队列**，取模%

### 3.2.4 数组模拟环形队列

对数组模拟队列的优化，充分利用数组，因此将数组看作是一个环形的（通过**取模的方式**来实现）。

**分析说明**

1. front指向当前队列头元素，初始位置为0
2. rear指向队列尾元素的下一个位置，初始位置为0
3. 当(rear+1)%maxSize=front时 表示队列满了
4. 当rear=front时表示队列为空
5. 当队列增加元素时rear=(rear+1)%maxSize
6. 当元素从队列里取出时front=(front+1)%maxSize

<img src="数据结构和算法.assets/image-20210923233150887.png" alt="image-20210923233150887" style="zoom:50%;" />

# 第四章 链表

## 4.1 链表介绍

链表是有顺序的列表，它在内存中存储如下：

<img src="数据结构和算法.assets/image-20210926235349178.png" alt="image-20210926235349178" style="zoom:50%;" />

1. 链表是以节点的方式来存储，是链式存储。
2. 每个节点包含一个data域，一个next域
3. 链表的各个节点不一定是连续存储的
4. 链表分带头节点和不带头节点的的链表，根据实际的需求来确定

## 4.2 单链表的应用实例

> 使用带头节点的单向链表实现英雄排行榜管理。完成对英雄人物的增删改查操作



**直接添加到链表尾部逻辑分析**

- 链表头节点用来做为牵引头，不移动

- 当节点的next属性为空时表示链表最后

- 添加节点时，从头节点获取第一个有效数据，开始遍历链表找到最后一个节点，将待添加的节点添加到最后



**按顺序添加节点分析**

- 从头节点开始获取有效节点（next）开始进行遍历链表

- 判断是否到达链表的最后，如果是则可以直接添加，否则进行下一步
- 判断当前节点的下一个节点的值是否大于要添加的节点的值，是跳出循环进行下一步，否继续遍历
- 判断当前节点的下一个节点的值是否等于要添加的节点的值，是跳出循环进行下一步，同时标识有相同节点，否继续遍历
- 判断是否是相同的节点，如果是相同的节点，输出提示不进行添加，如果不是相同节点进行下一步
- 将待添加节点的next指向当前节点的next，再将当前节点的next指向待添加节点

<img src="数据结构和算法.assets/image-20210926233401806.png" alt="image-20210926233401806" style="zoom:50%;" />

**删除节点逻辑分析**

- 如果到最后节点了，说明不存在要删除的节点

- 找到需要删除节点的前一个节点temp
- 将temp.next=temp.next.next

**更新节点逻辑分析**

- 如果是空节点，则更新操作不能完成，否则进行下一步
- 判断是否是要更新的节点，是则更新，否继续循环查找

## 4.3 单链表面试题

**求单链表有效节点的个数**

- 遍历链表，进行加一，直到最后一个节点

**查找单链表中倒数第k个节点**

- 判断k是否有效，即k不能小于等于0，也不能大于有效节点个数
- 倒数第k个就是正数第（length-k）个
- for循环遍历到第（length-k）个节点，就是要查找的倒数第k个节点

**单链表反转**

- 创建一个新的头节点revertHead，
- 对要反转的链表进行遍历，遍历时将当前遍历的节点取出，放到新的链表的最前面
- 将原来链表的头节点的next指向revertHead的next

**合并两个有序链表**

- 其实就是对链表的节点进行有序添加



## 4.4 双向链表应用实例

### 4.4.1 双向链表的操作分析和实现

- next指向当前节点的下一个节点
- pre指向当前节点的前一个节点

**单向链表的缺点分析**

- 单项链表的查找方向只能是一个方向，而双向链表可以向前或者向后查找
- 单项链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除

**双向链表的遍历**

遍历的方式和单链表一样，区别是双向链表可以向前查找，也可以向后查找

**添加节点到双向链表的最后**

- 先找到尾节点temp
- 让temp.next=newNode，同时让newNode.pre=temp

**双向链表的修改**

修改和单向链表一样

**双向链表的删除**

- 找到要删除的节点temp
- 执行temp.pre.next=temp.next，同时让temp.next.pre=temp.pre

## 4.5 单向环形链表

如下图所示是一个节点和多个节点时单向环形链表的状态。

当只有一个节点时，该节点的next域指向自己。

![image-20211007094049356](数据结构和算法.assets/image-20211007094049356.png)

## 4.6 单向环形链表应用场景

Josephu（约瑟夫）问题

Josephu问题为:设编号为 1，2，... n 的 n 个人围坐一圈，约定编号为 k(1<=k<=n)的人从 1 开始报数，数 到 m 的那个人出圈，它的下一位又从 1 开始报数，数到 m 的那个人又出圈，依次类推，直到所有人出列为止，由 此产生一个出圈编号的序列。

提示:用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。

## 4.7 Josephu问题

需要一个first变量，用来代表环的起始。

### 4.7.1 初始化环

- 环的大小应该不小于1，否则无意义
- 一个指向当前末尾的节点变量currentNode，保证currentNode.next=first
- 添加的节点temp

**添加节点的操作步骤**

1. 创建一个节点temp

2. 判断节点编号是不是1即第一个节点，如果是就让first变量指向它，同时让currentNode也指向它，然后设置currentNode.next=first；

3. 如果不是一号节点，让currentNode.next=temp；然后让currentNode指向temp，然后设置currentNode.next=first；

![image-20211007103959269](数据结构和算法.assets/image-20211007103959269.png)

### 4.7.2 出圈

**出圈的操作步骤**

1. 创建一个辅助节点helperNode，该节点初始指向队列的末尾节点。

2. 根据startNo，同步的移动helperNode和first，此时helperNode的next指向first

3. 然后再找到要出圈的节点delNode，根据计数的次数countNo。循环得到delNode的位置
4. 让firstNode指向delNode.next，让helperNode.next指向first节点helperNode.next=first

![image-20211007115702377](数据结构和算法.assets/image-20211007115702377.png)

# 第五章 栈

## 5.1 栈的一个实际需求

计算表达式的值

![image-20211007223208331](数据结构和算法.assets/image-20211007223208331.png)

计算机底层是如何运算得到结果的? 我们看这个算式 7 * 2 * 2 - 5, 但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)

## 5.2 栈的介绍

1. 栈也称为stack
2. 栈是一个先入后出的有序列表
3. 栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端称为**栈顶**，另一端为固定的一端称为**栈底**。
4. 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶；而删除元素则刚好相反，最后放入的元素最先被删除，最先放入的元素最后被删除
5. 如下图所示

![image-20211007223803375](数据结构和算法.assets/image-20211007223803375.png)

## 5.3 栈的应用场景

1. 子程序的调用：在跳往子程序前，会先将当前程序的下个指令的地址存到栈中，直到子程序执行完后在将地址取出，以回到原来的程序中
2. 处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入了栈中
3. 表达式的转换（中缀表达式转后缀表达式）与求值
4. 二叉树的遍历
5. 图的深度优先搜索法

## 5.4 栈的快速入门

1. 用数组模拟栈的使用，由于栈是一种有序列表，所以可以使用数组的结构来存储栈的数据结构
2. 实现思路如下：
   1. 定义top表示栈顶，初始值为-1
   2. 入栈操作，top++;stack[top]=value
   3. 出栈操作，int value=stack[top]; top--;

![image-20211008222846222](数据结构和算法.assets/image-20211008222846222.png)

​	

## 5.5 栈实现综合计算器（中缀表达式）

使用栈来实现综合计算器（此时只有正整数的加减乘除运算）。

输入一个表达式[7\*2\*2-5+1-5+3]计算结果。

思路分析：

![image-20211008222846222](数据结构和算法.assets/image-20211010222846222.png)

## 5.6 逆波兰计算器

### 5.6.1 前缀表达式

前缀表达式又称波兰表达式。前缀表达式的运算符位于操作数之前。

举例： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

**前缀表达式的计算过程**

从右至左扫描表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符对它们做响应的计算，并将结果入栈；重复这个过程直到表达式最左端，最后运算得出的值就是表达式的计算结果。

举例：(3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:

1. 从右至左扫描，将6、5、4、3压入栈中
2. 遇到+运算符，因此弹出3和4，计算出3+4的值，得到7，再将7入栈
3. 接下来是x运算符，因此弹出7和5，计算出7x5=35，将35入栈
4. 最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果

### 5.6.2 中缀表达式

中缀表达式就是常见的运算表达式，如(3+4)×5-6。

中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)

### 5.6.3 后缀表达式

后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

举例： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

| 正常表达式 | 逆波兰表达式  |
| ---------- | ------------- |
| a+b        | a b +         |
| a+(b-c)    | a b c - +     |
| a+(b-c)*d  | a b c – d * + |
| a+d*(b-c)  | a d b c - * + |
| a=1+3      | a 1 3 + =     |

**后缀表达式计算过程**

从左至右扫描表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈；重复这个过程直到表达式最右端，最后运算得出的值就是表达式的计算结果。

举例：(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

1. 从左至右扫描，将3和4压入栈中
2. 遇到运算符+，因此弹出3和4，计算出3+4的值，得到7，再将7入栈
3. 将5入栈
4. 接下来是 x 运算符，因此弹出5和7，计算7x5的值，得到35，将35入栈
5. 将6入栈
6. 接下来是 - 运算符，因此弹出35和6的值，计算35-6的值，得到29，由此得到最终结果。

### 5.6.4 逆波兰计算器

逆波兰表达式就是计算后缀表达式的值，这里使用jdk提供的Stack栈数据结构

## 5.7 中缀表达式转化为后缀表达式

在逆波兰表达式实现计算器中可以发现后缀表达式实现起来比较方便，但是得到后缀表达式的结果手动实现比较难，尤其表达式很长的情况下。下面看下将中缀表达式转为后缀表达式的步骤。

### 5.7.1 实现步骤

注意：*下面步骤中说的运算符是指加减乘除等运算符，左右括号()使用操作符表示，同时操作符没有优先级，只有运算符有优先级*

1. 初始化两个栈，运算符栈s1和中间结果存储的栈s2
2. 从左至右扫描中缀表达式
3. 遇到操作数时，将其压入到栈s2中
4. 遇到运算符时，将其与s1栈顶符号的优先级比较
   1. 如果s1栈顶为空，或者栈顶运算符为左括号"("，则直接将此运算符入栈到s1
   2. 否则，若优先级比栈顶运算符高，也将此运算符入栈s1
   3. 否则，将s1栈顶的符号弹出并压入到s2中，再次转到4.1
5. 遇到括号时
   1. 如果是左括号，则直接压入到s1栈中
   2. 如果是右括号，则依次弹出s1栈顶的符号，并压入到s2栈中，直到遇到左括号为止，此时将这一对括号丢弃
6. 重复步骤2-5，直到表达式扫描结束
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

### 5.7.2 举例说明

将中缀表达式“1+((2+3)*4)-5”转换为后缀表达式的过程如下：

| 扫描到的元素   | s2（栈底->栈顶）  | s1（栈底->栈顶） | 说明                                                         |
| -------------- | ----------------- | ---------------- | ------------------------------------------------------------ |
| 1              | 1                 |                  | 数字，直接入栈                                               |
| +              | 1                 | +                | 运算符，s1栈顶为空                                           |
| (              | 1                 | + (              | 是左括号，直接入栈                                           |
| (              | 1                 | + ( (            | 是左括号，直接入栈                                           |
| 2              | 1 2               | + ( (            | 数字，直接入栈                                               |
| +              | 1 2               | + ( ( +          | 运算符，此时s1栈顶是左括号，直接入栈                         |
| 3              | 1 2 3             | + ( ( +          | 数字，直接入栈                                               |
| )              | 1 2 3 +           | + (              | 右括号，循环弹出s1： 弹出+号压入到s2，直到遇到(，丢弃这一对括号 |
| *              | 1 2 3 +           | + ( *            | 运算符，此时s1栈顶是左括号，直接入栈                         |
| 4              | 1 2 3 + 4         | + ( *            | 数字，直接入栈                                               |
| )              | 1 2 3 + 4 *       | +                | 右括号，循环弹出s1： 弹出*号压入到s2，直到遇到(，丢弃这一对括号 |
| -              | 1 2 3 + 4 * +     | -                | 减号，此时s1栈顶是+ ，减号的优先级不比加号高，将s1栈顶的符号弹出并压入到s2中，继续和s1栈顶比较，这个时候s1空了，那么减号直接入栈 |
| 5              | 1 2 3 + 4 * + 5   | -                | 数字，直接入栈                                               |
| 表达式扫描结束 | 1 2 3 + 4 * + 5 - |                  | 将s1中的弹出到s2                                             |

最后的结果：1 2 3 + 4 * + 5 -

### 5.7.3 代码实现

注意：由于s2在实际操作中就是不断的添加元素，为了方便得到最后结果，在代码实现时可以使用List来代替

# 第六章 递归

## 6.1 递归应用场景

递归：recursion

## 6.2 递归的概念

简单说：递归就是方法本身调用自己。递归有助于编程者解决负责复杂的问题，同时可以让代码变得简洁。

## 6.3 递归的调用机制

方法区栈

## 6.4 递归解决的问题

1. 一些数学问题：8皇后、汉诺塔、阶乘、迷宫问题、球和篮子问题（Google编程大赛）
2. 一些算法中也会用到递归：快排、二分查找、归并排序、分治算法
3. 将用栈解决的问题使用递归解决代码比较简洁

## 6.5 递归需要遵守的规则

1. 在执行递归方法时，会将新的方法压入到方法区栈中
2. 方法中的局部变量是独立的，不会相互影响
3. 如果方法中使用的是引用类型变量，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则进入无限循环就会出现StackOverflowError。

## 6.6 递归-迷宫问题



## 6.7 递归-八皇后问题(回溯算法)

### 6.7.1 八皇后问题介绍

八皇后问题，是一个古老而著名的问题，是回溯算法的经典案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8X8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：**任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)**

<img src="数据结构和算法.assets/image-20211014222332316.png" alt="image-20211014222332316" style="zoom:70%;" />

### 6.7.2 八皇后问题算法思路分析

1. 第一个皇后先放第一行第一列
2. 第二个皇后放在第二行第一列，判断是否冲突，如果冲突就放在第三列依次把所有列放完，直到找到一个合适的
3. 第三个皇后放在第三行，还是第一列、第二列...直到第八个皇后也能放在一个不冲突的位置，算是找到了一个正确的解
4. 当得到一个正确的解时，在栈回退到上一个栈时，就会开始回溯。即将第一个皇后放在第一列的所有正确解找到
5. 然后将第一个皇后放在第一行第二列，后面继续循环执行1、2、3、4步骤，直到第一个皇后放到第一行第八列走完，得到所有的结果。

**说明**

一个8X8的棋盘，理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法用一个一维数组解决问题。比如：arr[8] ={0 , 4, 7, 5, 2, 6, 1, 3}表示的含义是arr的下标表示第几个皇后即行，arr[index]的值表示列。

**两个点在同一个斜线**

点(x1,y1)和点(x2,y2)如果abs(x1-x2)=abs(y1-y2)那么两个点在一个斜线上

# 第七章 排序算法

## 7.1 排序算法的介绍

排序也称排序算法，排序是将**一组数据**，依**指定的顺序**进行**排列的过程**。

## 7.2 排序的分类

1. 内部排序：指将需要处理的数据都加载到**内存**中进行排序。
2. 外部排序：当**数据量过大**，无法全部加载到内存中，需要借助**外部存储**进行排序。

**常见的算法分类**

<img src="数据结构和算法.assets/image-20211018214826450.png" alt="image-20211018214826450" style="zoom:50%;" />

## 7.3 算法的时间复杂度

### 7.3.1 度量一个程序执行时间的两种方法

1. 事后统计法

   这种方法存在两个问题：一是想要对设计的算法的运行性能进行评价，需要实际运行该程序；二是所得到的时间依赖于计算机的硬件、软件等环境因素，这种方式，要在同一台计算机的相同状态下进行，才能比较哪个算法速度更快

2. 事前估计的方法

   通过分析某个算法的**时间复杂度**来判断哪个算法更优。

### 7.3.2 时间频度

**基本介绍**

一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度**。

**举例说明**

- 忽略常数项

<img src="数据结构和算法.assets/image-20211018220113667.png" alt="image-20211018220113667" style="zoom:50%;" />

<img src="数据结构和算法.assets/image-20211018220151077.png" alt="image-20211018220151077" style="zoom:50%;" />

​	结论: 
​	2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略
​	3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略

- 忽略低次项

<img src="数据结构和算法.assets/image-20211018220312740.png" alt="image-20211018220312740" style="zoom:50%;" />

<img src="数据结构和算法.assets/image-20211018220330309.png" alt="image-20211018220330309" style="zoom:50%;" />

​	结论: 
​	2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10
​	n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20

- 忽略系数

<img src="数据结构和算法.assets/image-20211018220434095.png" alt="image-20211018220434095" style="zoom:50%;" />

<img src="数据结构和算法.assets/image-20211018220453287.png" alt="image-20211018220453287" style="zoom:50%;" />

​	结论: 
​	随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。
​	而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键

### 7.3.3 时间复杂度

1. 一般情况下**算法中的基本操作语句的重复执行次数是问题规模n的某个函数**，用T(n)表示，若有某个辅助函数f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 **T(n)=**O**( f(n) )**，称O( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。

2. T(n) 不同，但时间复杂度可能相同。 如:T(n)=n2+7n+6 与 T(n)=3n2+2n+2 它们的 T(n) 不同，但时间复杂 度相同，都为 **O(n**2**)**。
3. 计算时间复杂度的方法:
   1. 用常数 1 代替运行时间中的所有加法常数 T(n)=n2+7n+6 => T(n)=n2+7n+1
   2. 修改后的运行次数函数中，只保留最高阶项 T(n)=n2+7n+1 => T(n) = n2
   3. 去除最高阶项的系数 T(n) = n2 => T(n) = n2 => O(n2)

### 7.3.4 常见的时间复杂度

1. 常数阶O(1)

   <img src="数据结构和算法.assets/image-20211018221309905.png" alt="image-20211018221309905" style="zoom:50%;" />

2. 对数阶O(log2n)

   <img src="数据结构和算法.assets/image-20211018221328703.png" alt="image-20211018221328703" style="zoom:80%;" />

   在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) .

3. 线性阶O(n)

   <img src="数据结构和算法.assets/image-20211018221356286.png" alt="image-20211018221356286" style="zoom:90%;" />

4. 线性对数阶O(nlog2n)

   <img src="数据结构和算法.assets/image-20211018221504644.png" alt="image-20211018221504644" style="zoom:80%;" />

   线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)

5. 平方阶O(n^2)

   <img src="数据结构和算法.assets/image-20211018221538255.png" alt="image-20211018221538255" style="zoom:70%;" />

6. 立方阶O(n^3)

7. k 次方阶 O(n^k)

8. 指数阶O(2^n)

<img src="数据结构和算法.assets/image-20211018221150573.png" alt="image-20211018221150573" style="zoom:50%;" />

常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

### 7.3.5 平均时间复杂度和最坏时间复杂度

1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2. 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是:最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关

<img src="数据结构和算法.assets/image-20211018221757376.png" alt="image-20211018221757376" style="zoom:50%;" />

## 7.4 算法的空间复杂度

### 7.4.1 基本介绍

1. 类似于时间复杂度，一个算法的空间复杂度(SpaceComplexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。
2. 空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的 临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如快速排序和归并排序算法**,** 基数排序就属于这种情况
3. 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache)和算法(基数排序)本质就是用空间换时间.

## 7.5 冒泡排序

### 7.5.1 冒泡排序基本思想

从小到大排序

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一轮结束后，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。

对于n个数字，当n-1个位置都确定时，那么这个待排序数组就是排序完整的。由于每一轮排序可以确定一个元素，所以n个数需要n-1轮，每轮确定冒出一个最值

### 7.5.2 冒泡优化

优化：如果在某趟排序寻找过程中，没有发生一次交换，说明当前序列已经顺序了，可以提前结束冒泡排序。

## 7.6 选择排序

### 7.6.1 基本介绍

选择排序也属于内部排序算法，是从待排序的数据中，按指定的规则选出某一元素，再按照规定排序方式交换位置后达到排序的目的。

### 7.6.2 选择排序的思想

从小到大排序

- 第一轮循环从arr[0]-arr[n-1]中选取最小值，与arr[0]比较进行交换
- 第二轮循环从arr[1]-arr[n-1]中选取最小值，与arr[1]比较进行交换
- 第i轮循环从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]比较进行交换
- 第n-1次循环从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]比较进行交换

也是每轮循环得到一个最值，所以也是需要n-1次循环

## 7.7 插入排序

### 7.7.1 基本介绍

插入排序属于内部排序算法，对待排序的元素以插入的方式找寻该元素适当位置，以达到排序的目的。

### 7.7.2 插入排序的思想

把n个待排序的元素看成一个有序列表和一个无序列表，开始时有序表只包含一个元素，无序表包含n-1个元素，排序过程从无序表中取出第一个元素，使其与有序列表进行比较，为其找到合适的位置，使之成为新的有序表。

![image-20211030135303528](数据结构和算法.assets/image-20211030135303528.png)

## 7.8 希尔排序

### 7.8.1 插入排序存在的性能问题

当较小的数在待排序数组的后面时，数组移动的次数明显增多，对效率有影响。

如数组arr={2,3,4,5,6,1}，当待插入数是1时，整个过程是这样的。

<img src="/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211031085636610.png" alt="image-20211031085636610" style="zoom:50%;" />

几乎所有的数组都进行了移动，比较影响性能

## 7.8.2 希尔排序法简介

希尔排序是希尔在1959年提出的一种排序算法，希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

### 7.8.3 希尔排序基本思想

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

### 7.8.4 希尔排序法示意图

<img src="/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211031105903083.png" alt="image-20211031105903083" style="zoom:50%;" />

<img src="/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211031105958010.png" alt="image-20211031105958010" style="zoom:50%;" />

### 7.8.5 希尔排序实现方式

希尔排序是基于插入排序实现，因此在给待排序元素设置位置时，有**交换**和**移动**两种实现方式。性能上还是有差别的。

## 7.9 快速排序

### 7.9.1 快速排序简介

快速排序是对冒泡排序的一种改进。基本思想是一趟排序将待排序的数据分割成独立的两个部分，其中一部分的所有数据都比另外一部分的所有数据都要小。然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行。以此达到整个数据变成有序序列。

### 7.9.2 快速排序基本思想

1. 先从待排序队列中取出一个数作为基准数
2. 分区过程，将比这个数大的放在它的右边，比这个数小的放在它的左边
3. 在对左右区间重复以上步骤，直到各区间只有一个数

### 7.9.3 快速排序过程解析

快速排序的过程可以拆解为：挖坑填数+分治。

以一个数组为例：

![image-20211103212318729](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211103212318729.png)

取中间一个数作为基数，l为数组起始左边下标，r为数组起始右边下标，emptyIndex为当前坑位的下标，pivot为当前选取的基数变量。

l=0，r=9，emptyIndex=4，pivot=arr[emptyIndex]=60;

由于已经将arr[emptyIndex]的数保存到pivot变量了，可以认为该位置是个空坑，可以让其他数填充了；

此时l=0，从左边开始找大于pivot的数，发现当l=0时，arr[0]=72，大于pivot符合条件，将arr[0]挖出来填充到上一个坑arr[4]的位置上，即arr[4]=arr[0]，让emptyIndex=0；

![image-20211103212515381](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211103212515381.png)



此时r=9，从右边开始找小于等于pivot的数，发现当r=8时，arr[8]=48，小于pivot符合条件，将arr[8]挖出来填充到上一个坑arr[0]的位置上，即arr[0]=arr[8]，让emptyIndex=8；

![image-20211103212640968](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211103212640968.png)



此时l=0，从左边开始找大于pivot的数，发现当l=3时，arr[3]=88，大于pivot符合条件，将arr[3]挖出来填充到上一个坑arr[8]的位置上，即arr[8]=arr[3]，将emptyIndex=3；

![image-20211103213015125](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211103213015125.png)



此时r=8，从右边开始找小于等于pivot的数，发现当r=5时，arr[5]=42，小于pivot符合条件，将arr[5]挖出来填充到上一个坑arr[3]的位置上，即arr[3]=arr[5]，将emptyIndex=5；

![image-20211103213312932](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211103213312932.png)



此时l=3，从左边开始找大于pivot的数，发现当l=4时，arr[4]=72，大于pivot符合条件，将arr[4]挖出来填充到上一个坑arr[5]的位置上，即arr[5]=arr[4]，将emptyIndex=4；

![image-20211103213544407](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211103213544407.png)



此时r=5，从右边开始找小于等于pivot的数，发现当r=4时，等于了l，这个时候结束循环。将pivot设置到当前坑的位置上，即arr[emptyIndex]=pivot，最后数组的状态如下所示：可以发现60的左边的数都比60小，60右边的数都比60大。

![image-20211103213848123](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211103213848123.png)



注意事项：

- 在过程中要创建临时的l和r，不能使用实参left和right值，因为循环过程中会对下标进行移动
- 注意临界值等于的处理，会出现死循环

## 7.10 归并排序

### 7.10.1 归并排序介绍

归并排序是利用归并的思想是实现的排序方法，该算法采用经典的分治策略。分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案合并在一起，即分而治之。

### 7.10.2 归并排序基本思想

![图片1](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/图片1.png)

### 7.10.3 归并排序过程解析

将上图中最后一次合并的过程图解如下：

1. i，j分别指向两个子数组的起始位置
2. 比较arr[i]和arr[j]，得到将arr[j]填充到temp数组中，将j++
3. 重复上面的步骤，直到一个子数组末尾结束
4. 将另外的一个数组中剩余的数依次填充到temp数组中
5. 将temp数组中的数拷贝到arr数组中

![图片2](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/图片2.png)

![图片3](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/图片3.png)

## 7.11 基数排序

### 7.11.1 基数排序介绍

1. 基于排序属于分配式排序，又称桶子法或bin sort。它是通过键值的各个位的值，将要排序的元素分配至某些桶中，达到排序的作用
2. 基数排序法属于稳定型的排序，基数排序法是效率高的稳定排序法
3. 基数排序法是桶排序的扩展
4. 基数排序是1887年赫尔曼 何乐礼发明的。

### 7.11.2 基数排序基本思想

1. 将所有待排序的数统一为同样的数位长度，数位短的数前面补零，即假如原数组为[10,2,213]，则可以看为[010,002,213]，同时创建一个二维数组的十个桶，每个桶大小是待排序数组的长度即bucket\[10][a r r .length]，然后开始循环;
2. 第一次循环按照数组中待排序的数的个位，将其放到对应的桶中直到数组循环完毕
3. 将桶中的数组按顺序复制到待排序数组中
4. 重复第二、三步
5. 最后将待排序数组就是已经排序的数组

![image-20211106224357796](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211106224357796.png)

### 7.11.3 基数排序的说明

1. 基数排序是对桶排序的扩展
2. 基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成oom。因为要创建十个桶，每个桶大小是待排序数组的长度。即有 4size * 10 * arr.length
3. 基数排序是稳定
4. 这里对有负数的场景没有讨论

## 7.12 常用排序算法总结和对比

### 7.12.1 比较图

![image-20211106225833698](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211106225833698.png)

### 7.12.2 相关术语解释

1. 稳定排序：如果a原本在b前面，同时a=b，排序之后a仍然在b的前面
2. 不稳定排序：如果a原本在b前面，同时a=b，排序之后a可能出现在b的后面
3. 内排序：所有排序操作都在内存中外城
4. 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
5. 时间复杂度：一个算法执行所耗费的时间
6. 空间复杂度：运行完一个程序所需内存的大小
7. n：数据规模
8. k：桶的个数
9. In-place：不占用额外内存
10. Out-place：占用额外内存

# 第八章 查找算法

## 8.1 查找算法介绍

在Java中，常用的查找算法有四种：

1. 顺序查找
2. 二分查找
3. 插值查找
4. 斐波那契查找

## 8.2 线性查找算法

线性查找就是遍历数列，查找是否有待查询元素

## 8.3 二分查找算法

### 8.3.1 二分查找

二分查找要求数列是有序的。

### 8.3.2 二分查找思路

1. 首先确定数列的中间下标mid=(left+right)/2
2. 比较findVal和arr[mid]的值
3. 如果findVal大于arr[mid]，则递归向右查找
4. 如果findVal小于arr[mid]，则递归向左查找
5. 如果findVal等于arr[mid]，则说明找到了值
6. 如果找到了就返回，结束递归
7. 如果递归到left>right也没有找到findVal，也需要结束递归，说明查无此元素

## 8.4 插值查找算法

### 8.4.1 插值查找算法介绍

插值查找算法类似于二分查找，不同的是插值查找每次的mid是根据要查找的值计算得出，即可以理解为要查找的值参与了查找自己的过程，所以插值查找也叫做自适应查找。

由于要查找的值参与了计算mid的过程，因此在一定情况下可以减少二分查找递归的次数。

在二分查找时，mid的计算方法是mid=(left+right)/2

在插值查找时，mid的计算方法是mid = left + (right - left) * (findVal - arr[left]) / (arr[right - arr[left]]);

### 8.4.2 插值查找算法过程

举例说明插值在1-100 的数列中查找10的过程。

使用上面提到的公式mid=0 + (99 - 0) * (10 - 1) / (100 - 1) =9 

在数列arr中arr[9]就是等于10，此时只递归了一次

## 8.5 斐波那契（黄金分割法）查找算法

### 8.5.1 斐波那契（黄金分割法）介绍

1. 黄金分割点是值把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。比值是一个无理数，取其前三位数字的近似值是0.618。由于按照此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。
2. 斐波那契数列{1,1,2,3,5,8,13,21,34,55}。发现斐波那契数列的两个相邻数的比例越来越接近黄金分割值。即该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。

### 8.5.2 斐波那契查找原理

斐波那契查找原理与前两种相似，仅仅是改变了中间节点mid的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1，F代表斐波那契数列。

![image-20211107211553241](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211107211553241.png)



1. 由于斐波那契数列F[k]=F[k-1] + F[k-2]的性质。例如当k=6时，那么F[k]=8、F[k-1]=5、F[k-2]=3。即长度为8的数列可以分为长度为5和长度为3的两个数列。
2. 那么mid位置的计算low+F(k-1)-1
3. 类似的，每一个子段也可以用相同的方式分割
4. 但是顺序表的长度不一定刚好等于F[k]，所以需要将原来的顺序表长度n增加至F[k]。在扩充时增加的元素使用原数组最后值填充
5. 循环进行区间分割，查找中间值
6. 判断中间值和目标值的关系，确定更新策略

### 8.5.3 斐波那契查找过程

1. 构建一个斐波那契队列

   ```.txt
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]
   ```

   

2. 将待查找数列填充合适的长度

   假设待查找数据队列如下：

   ```.txt
   [1, 2, 4, 6, 7, 9, 13,
    16, 17, 21, 23, 25, 27, 
    31, 45, 56, 58, 61, 65, 
    67, 73, 75, 88, 93, 102]
   ```

   这里共有25个元素，不等于斐波那契数列中任何F(n)，此时，策略是**采用“大于数组长度的最近一个斐波那契数值”**。比如当前数组长度为25，斐波那契数列中大于25的最近元素为34。

3. 填充后待查找数列如下

   ```.txt
   [1, 2, 4, 6, 7, 9, 13,
    16, 17, 21, 23, 25, 27, 
    31, 45, 56, 58, 61, 65, 
    67, 73, 75, 88, 93, 102,102,102,102,102,102,102,102,102,102]
   ```

   此时共34个元素

4. 循环进行区间分割，查找中间值

   这一个步骤与二分查找和插值查找相似，都是不断的缩小搜索区间，进而确定目标值的位置。每次分割中间位置的计算如下：mid=left + F(n-1) -1

   此时**数组被分割为左右两个区间，左边区间含有F(n-1)个元素**

5. 判断中间值和目标值的关系，确定更新策略

   中间值和目标值有三种大小关系，分别对应三种处理方式：

   - 相等，则查找成功，返回中间位置即可
   - 中间值小于目标值，则说明目标值位于中间值到右边界之间（即右区间），右区间含有F(n-2)个元素，所以n应该更新为n=n-2
   - 中间值大于目标值，这说明目标值位于左边界和中间值之间（即左区间），左区间含有F(n-1)个元素，所以n应更新为n=n-1

# 第九章 哈希表

## 9.1 Google上机题

有一个公司，当有新员工报道时，要求将该员工的加入（id、姓名），当输入该员工ID时，输出该员工信息。不实用数据库，尽量节省内存，速度越快越好。

## 9.2 哈希表基本介绍

散列表也叫哈希表，是根据关键码值而直接进行访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

![image-20211110220450258](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211110220450258.png)

# 第十章 树结构基础部分

## 10.1 二叉树

### 10.1.1 为什么需要树这种数据结构

**数组存储方式分析**

- 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
- 缺点：如果要检索某个具体的值，或者插入、删除元素会有整体移动，效率较低

**链式存储方式分析**

- 优点：在另一个角度对数组存储方式有优化（在插入、删除时不需要再有整体移动）
- 缺点：在进行检索具体值时，效率仍然低

**树存储方式分析**

能提高数据存储、读取的效率，比如利用二叉排序树，既可以保证数据的检索速度，同时也可以保证数据的插入、删除、修改的速度。

### 10.1.2 树相关概念

- 节点
- 根节点
- 父节点
- 子节点
- 叶子节点（没有子节点的节点）
- 节点的权（节点值）
- 路径（从root节点找到该节点的路线）
- 层
- 子树
- 树的高度（树的最大层）
- 森林（多棵子树构成森林）

### 10.1.3 二叉树的概念

树有很多种，每个节点最多只能有两个子节点的树，成为二叉树。二叉树分为左节点和右节点。

![image-20211115235024931](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211115235024931.png)



**满二叉树**

如果二叉树所有叶子节点都在最后一层，并且总节点总数=2^n-1，n为层数，则我们称为满二叉树。

![image-20211115235313146](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211115235313146.png)

**完全二叉树**

如果二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点从左边开始连续；倒数第二层的叶子节点从右边开始连续，则称为完全二叉树。

![image-20211115235326618](/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211115235326618.png)

### 10.1.4 二叉树遍历的说明

使用前序、中序、后序遍历二叉树：

- 前序遍历：先父节点，在左节点，最后右节点
- 中序遍历：先左节点，在父节点，最后右节点
- 后序遍历：先左节点，在右节点，最后父节点

总结：看父节点的位置，就确定是前序、中序、后序了。

### 10.1.5 二叉树遍历思路

**前序遍历**

- 先输出当前节点
- 判断当前节点有没有左节点，如果有则递归前序遍历左节点
- 判断当前节点有没有右节点，如果有则递归前序遍历右节点

### 10.1.6 查找指定节点

**前序查找**

1. 先判断当前的节点是否是要查找的节点，如果是查找结束
2. 判断当前节点的左节点是否为null，进行下一步，如果不为null，递归进行前序查找
3. 判断当前节点的右节点是否为null，进行下一步，如果不为null，递归进行前序查找
4. 如果执行到了这里说明没有查找到节点

### 10.1.7 删除指定节点

*注意这里实现的场景*

1. 如果节点是叶子节点，直接删除该节点
2. 如果节点不是叶子节点，则删除该子树

**实现思路**

由于当前的二叉树，只能由父节点找到子节点，不能通过子节点找到父节点。所以在做删除置空操作时，是判断当前节点的子节点是否是要删除的节点，如果是判断当前节点是否为待删除节点时，将无法进行删除操作。

- 先判断根节点是否为null，如果是直接返回，当前树是空树；如果非空，判断根节点是否是要删除节点
- 判断当前节点的左节点是否不为null，且是要删除的节点，如果是则删除当前节点的左节点结束
- 判断当前节点的右节点是否不为null，且是要删除的节点，如果是则删除当前节点的右节点结束
- 如果当前节点的左节点不为null，进行左节点递归删除
- 如果当前节点的右节点不为null，进行右节点递归删除

## 10.2 顺序二叉树

### 10.2.1 顺序二叉树的概念

**基本说明**

从数据存储来看，数组存储和树的存储方式可以相互转换。即**数组可以转换成树，树也可以转换成数组**。

<img src="/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211118211710725.png" alt="image-20211118211710725" style="zoom:50%;" />

注意：二叉树的节点序号，从0开始，这样可以和数组下标保持一致。

**顺序存储二叉树的特点**

- 顺序存储二叉树只考虑完全二叉树
- 第n个元素的左子节点为2*n+1
- 第n个元素的右子节点为2*n+2
- 第n个元素的父节点为(n-1)/2，其中这个地方n>0，0号节点是跟节点，没有父节点
- n表示二叉树中第几个元素，n从0开始

### 10.2.2 顺序存储二叉树遍历

一个数组arr{1,2,3,4,5,6,7}，以二叉树前序方式进行遍历。

### 10.2.3 顺序存储二叉树应用实例

堆排序会用到顺序存储二叉树

## 10.3 线索化二叉树

### 10.3.1 抛出问题

<img src="/Users/zhangdd/code/DataStructures-Algorithm/数据结构和算法.assets/image-20211123210922427.png" alt="image-20211123210922427" style="zoom:50%;" />

如上图所示二叉树，我们对其进行如下分析：

1. 当对该二叉树进行中序遍历时得到的队列是：[8,3,10,1,14,6]
2. 该二叉树的6，8，10，14四个节点存在没有使用的左右指针
3. 如果我们想充分利用各个节点的左右指针，让各个节点可以标识出自己的前驱、后继节点，该如何处理
4. 解决方案就是**线索二叉树**

*遍历二叉树得到的遍历队列，一个节点的前一个节点，称为前驱节点；后一个节点称为后继节点。*

### 10.3.2 线索二叉树简介

1. n个节点的二叉树中含有n+1个空指针域。计算方式：2\*n - (n-1) ；一个节点两个指针所以一共有2n个指针，n个节点的连接需要使用n-1个，所以还剩2\*n - (n-1)个空指针域。
2. 这种加上了线索的队列称为线索链表，相应的二叉树称为线索二叉树。根据线索性质的不同线索二叉树可以分为前序线索二叉树、中序线索二叉树、后序线索二叉树

### 10.3.3 线索二叉树应用案例

当线索化二叉树后，node节点的left和right属性有如下情况：

1. left指向的可能是左子树，也可能是前驱节点
2. right指向的可能是右子树，也可能是后继节点

